package ru.primetalk.sinapse.akka

import akka.event.{LoggingReceive, Logging}
import akka.actor.{Actor, ActorRef, Props}
import scala.collection.mutable
import ru.primetalk.sinapse.core._
import org.slf4j.MDC
import ru.primetalk.sinapse.akka.Signals
import ru.primetalk.sinapse.core.Signal
import ru.primetalk.sinapse.akka.Signals
import ru.primetalk.sinapse.core.DynamicSystem

/** Inner systems should register themselves via ready signal.*/
class StaticSuperSystemActor(superSystem : StaticSuperSystem) extends EscalatingActor {

   val log = Logging(context.system, this)
   val actorFactory = context

   val actors =
     superSystem.subsystems.map(system ⇒ (system,
       actorFactory.actorOf(Props(
         new DynamicSystemActor(
             StaticSuperSystemActor.systemToDynamicSystem(system))),
         system.name))).toMap
   val notStartedChildren = mutable.Set[ActorRef](actors.values.toSeq : _ *)
   val inputsToActors =
     superSystem.inputsToSystems.
       map(p ⇒ (p._1, p._2.map(actors(_)))).
       toMap[Contact[_], List[ActorRef]].
       withDefault(c ⇒ List())

   def processSignalsList(signals : List[Signal[_]]) = {
     MDC.put("akkaSource", ""+self.path)
     signals foreach (processSingleSignal(_))
   }

   def processSingleSignal[T](s : Signal[T]) {
     val actors = inputsToActors(s.contact : Contact[_])
     actors.foreach(actor ⇒ actor forward s)
   }
   def receive = LoggingReceive {
     case Signals(Nil) ⇒
       log.warning("Empty signals sent to SuperSystem")
     case Signals(l) ⇒
       processSignalsList(l)
     case s @ Signal(c, d) ⇒
       processSignalsList(s::Nil)
     case InitCompleted(child) ⇒
       if (notStartedChildren.contains(child))
         notStartedChildren -= child
       else
         throw new IllegalArgumentException(s"The actor $sender sent InitCompleted to $self but is absent in notStartedChildren (either foreigh or already completed).")
       if(notStartedChildren.isEmpty){
         context.parent ! InitCompleted(self)
         log.info(s"Init completed in $self sent to ${context.parent}")
       }
     case InitFailed(child, cause) =>
       log.error(cause, s"Child $child init failed.")
       context.parent ! InitFailed(self, cause)
     case nonSignalMessage ⇒
       val s = Signal(NonSignalWithSenderInput, (sender, nonSignalMessage))
       processSignalsList(s :: Nil)
   }
 }
/**
 * Actors that exchange signals.
 *
 * Inner processing is done with system signal processing.
 *
 * Integration of actors is based on an actor that has the system itself
 * and composes child actors.
 *
 * Children actors send all their output to parent.
 *
 * For productive work different actors should have some shared contacts.
 * In producers these contacts should be marked as output.
 * @author А.Жижелев
 */
object StaticSuperSystemActor {
  def systemToDynamicSystem(system : OuterSystem) : DynamicSystem = system match {
    case ds : DynamicSystem ⇒
      ds
    case s2 : StaticSystem ⇒
      SignalProcessing.toDynamicSystem(s2)
    case _ ⇒ throw new IllegalArgumentException(s"Cannot convert system to DynamicSystem: $system")
  }
  def systemToActor(system : OuterSystem) : Actor =
    new DynamicSystemActor(systemToDynamicSystem(system))

}


///** Sends raw data from input signals to the actor. All input contacts are treated equivalently.*/
//case class SimpleActorAdapter(
//		inputContacts: Set[Contact[_]],
//		name: String,
//		/** This actor can send signals to sender (reply). However they are not restricted by output contacts.*/
//		simpleActorRef:ActorRef) extends Component {
//	val outputContacts = Set[Contact[_]]()
//}
///** An actor that converts any raw data to signal and forwards it to contactsActor */
//class ActorSendingToContact[T](contactsActor : ActorRef, contact : Contact[T]) extends Actor {
//	def receive = {
//		case s @ Signal(c, d) if c == contact ⇒
//			contactsActor forward Signal(contact, d.asInstanceOf[T])
//		case msg ⇒
//			contactsActor forward Signal(contact, msg.asInstanceOf[T])
//	}
//}
//case class MultiOutputAdapter(
//		inputContacts: Set[Contact[_]],
//		outputContacts: Set[Contact[_]],
//		name: String)(
//		/** the function from some single signal on input contact to any number of output contacts.*/
//		val multiOutputAlgorithm:PartialFunction[Any,List[Signal[_]]]) extends Component
//case class ActorBuilder(
//	inputContacts : Set[Contact[_]],
//	outputContacts : Set[Contact[_]],
//	name : String)
//	(val actorFactory : (List[Signal[_]] ⇒ Any) ⇒ Actor) extends Component
//case class ArbitraryChildActorAdapter(
//	inputContacts : Set[Contact[_]],
//	outputContacts : Set[Contact[_]],
//	name : String,
//	/** the factory gets the ActorRef to parent (event hub).
//	 *   The Actor behind ActorRef only handles Signals. Thus a converter may be necessary. */
//	actorFactory : (ActorRef) ⇒ Actor) extends Component
///**
//  * This declarations leads to creation of intermediate actor that converts
//  *  input signals to raw data and then sends it to the actorRef. The replies of
//  *  that actor should not be signals. They come back to the intermediate actor
//  *  which applies mapping function replyMap to convert them to Signals.
//  *  Converts replies of the actor to contacts.
//  */
//case class ActorRefAdapter(
//	inputContacts : Set[Contact[Any]],
//	outputContacts : Set[Contact[Any]],
//	/** signals to input contacts are preprocessed before this map.
//	 *  This function should convert other messages to signals, if it can. */
//	replyMap : PartialFunction[Any, Signal[_]],
//	name : String,
//	actorRef : ActorRef) extends Component
//case class FunctionalSystem(
//		inputContacts: Set[Contact[Any]],
//		outputContacts: Set[Contact[Any]],
//		name: String,
//		actorFactory:(List[Signal[_]]=>Any) => Actor) extends Component
//		case ActorRefAdapter(inputContacts, _, replyMap, _, actorRef) =>
//			new Actor {
//				val processRequests:Receive = {
//					case Signal(c, d) if inputContacts.contains(c) ⇒ actorRef ! d
//				}
//				val processAnswers:Receive = replyMap.andThen(s => parent ! s)
//				def receive = processRequests orElse processAnswers
//			}
