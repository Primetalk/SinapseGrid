/**
 * Constructor that creates buffer component with single input
 * in: double, single buffered output  out: Array[Double].
 * When this component receives a new element it decides whether to
 * issue the frame or to accumulate.
 */
def CreateBuffer(length: Int):
  component (in: Double) >> (out: Array[Double])
    with (currentLength: Int = 0, currentBuffer: List[Double] = Nil) = { // BufferState(currentLength: Int = 0, currentBuffer: List[Double] = Nil)
        val buf = in  :: currentBuffer
        if(currentLength == length - 1) {
          out := buf
          currentBuffer := Nil
          currentLength := 0
        } else {
          currentBuffer := buf
          currentLength := currentLength + 1
        }
}

def CreateDigitalFilter(frameLength: Int) =
    component  (in: Array[Double]) >> (out: Array[Double])
        with (prevOutput: Array[Double] = Array.fill(frameLength)(0.0)) {
          // implementation of digital filter (mathematical implementation)
    }

val Unframer = component (in: Array[Double]) >> (out: Double) {
  out ::= in.toIterable
  /*
      for{ i <- in } {
        out := i
      }
  */
}

// NB: there is a delay before first output appears on output.
// in this case the delay is 160 ticks.
val Filter = component  (in: Double) >> (out: Double) with auto state {
  val frameLength = 160
  val Buffer = CreateBuffer(frameLength)
  val DigitalFilter = CreateDigitalFilter(frameLength)
  in >> buf1.in
  Buffer.out >> DigitalFilter.in
  DigitalFilter.out >> Unframer.in
  Unframer.out >> out

  //Parser.out.map(_ + 1) >> Shower.in
}
