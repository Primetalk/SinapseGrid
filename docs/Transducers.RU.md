# Трансдьюсеры

Задачи обработки потоков данных встречаются довольно часто.
В последнее время, актуальность алгоритмов, работающих с потоками
данных, увеличилась, в связи с распространением тематики больших данных.

Отличие алгоритмов потоковой обработки данных от "пакетной" заключается
в том, что объём данных, обрабатываемый алгоритмом, 
превышает объём памяти, используемой обработчиком.
Несмотря на такое простое изменение постановки задачи, это накладывает
существенные дополнительные ограничения на то, 
как можно решать такие задачи, и как это делать удобно, с минимальными
проблемами.

## Пример 1. Счётчик

Задача. В каждой строчке файла записано число Int.
Найти сумму чисел в файле.

Если файл имеет небольшой размер, то можно загрузить его в память и 
выполнить преобразование:

```scala
    val lines = loadLines("file.txt")
    val ints = lines.map(_.toInt)
    val result = ints.sum
```
В этой программе выполняются такие операции:
- загрузка строк из файла, 
- конвертация в целые числа, 
- суммирование.

Такая программа понятна и доступна, однако не будет работать
при небольшом объёме памяти, по сравнению с размером файла. 
Связано это с тем, что каждая операция выполняются целиком над всей
соответствующей коллекцией.

Для этой задачи можно предложить альтернативный способ решения,
при котором операции не требуют много памяти. 
Надо по мере загрузки строк, выполнять конвертацию в целые числа, и 
сразу суммировать эти числа, накапливая результат в аккумуляторе.

Возникает вопрос, как следует реализовывать отдельные операции,
чтобы их можно было удобно комбинировать? Желательно, 
чтобы получающаяся программа не очень сильно отличалась от вышеприведённой.

Здесь на помощь приходят "[трансдьюсеры](https://en.wikipedia.org/wiki/Finite-state_transducer)" 
или [конечные автоматы с выходом](https://ru.wikipedia.org/wiki/Конечный_автомат_с_выходом). 
Такой автомат обрабатывает входные сообщения, переходит между состояниями и 
выдаёт на выход какие-либо сообщения. Причём (1) в ответ на одно 
входное сообщение может быть сформировано как 0 выходных сообщений, 
так и несколько; (2) выходные сообщения, вообще говоря, могут 
формироваться без входного сообщения.

Примером такого трансдьюсера может быть конвертация строки в число. 
Здесь для каждой входной строки выдаётся либо 0 сообщений, либо 
одно сообщение, содержащее число. 

Другим примером служит накопитель суммы. При получении на вход
числа, изменяется внутреннее состояние накопителя - это число 
прибавляется к аккумулятору, а на выход ничего не передаётся.
При получении на вход служебного сигнала завершения потока чисел,
значение аккумулятора передаётся на выход (и, возможно, аккумулятор 
сбрасывается в 0).

Примером библиотеки, реализующей похожий подход, может служить fs2.

## Служебные сигналы и структура потока данных

Часть трансдьюсеров можно сконструировать, игнорируя тот факт, 
что мы имеем дело с потоком данных. Например, такие операции как
конвертация строки в число, или разбиение строки на слова, 
делаются без учёта служебных сигналов.
В то же время, сумматору требуется обработка служебного сигнала 
завершения потока, чтобы в нужный момент выдать на выход 
накопленную сумму.

Обработка больших потоков данных маленькими порциям приводит к 
деградации производительности. Например, если на вход поступает
аудиосигнал, а трансдьюсер выполняет цифровую фильтрацию, то 
при независимой обработке каждого отдельного отсчёта 
суммарно будет уходить больше времени, чем при обработке буфера,
содержащего много отсчётов. Поэтому поток данных буферизуется 
и разбивается на участки, которые обрабатываются пакетно. 
В терминологии fs2 такие пакеты называются Chunk'ами. 

Буферизация улучшает производительность с точки зрения
затрат вычислительных ресурсов, но, во-первых, требует больше 
памяти для обработки и, во-вторых, вызывает задержку обработки сигнала 
(latency). Поэтому размер буфера выбирается исходя из 
допустимого увеличения задержки.

## Последовательное соединение трансдьюсеров

Сигналы с выхода одного трансдьюсера могут быть переданы на 
вход другого трансдьюсера. При этом получится новый трансдьюсер. 
Мы не вводим новых абстракций, последовательное соединение является
логичным продолжением идеи трансдьюсеров.

## Параллельные трансдьюсеры

Зачастую нам требуется получить два разных значения 
по итогам обработки. Например, чтобы вычислить среднее значение, необходимо
получить сумму и количество чисел. При этом хотелось бы эти два
вычисления не смешивать, а скомбинировать из элементарных вычислений.
При этом можно обратить внимание, что вообще говоря, 
получающаяся конструкция уже не будет простым трансдьюсером,
т.к. будет иметь два выхода.

По-видимому, необходимо предложить абстракцию, подходящую для 
описания систем обработки сигналов, имеющих много входов и 
много выходов, и которая в частном случае одного входа и выхода
ведёт себя как простой трансдьюсер.
